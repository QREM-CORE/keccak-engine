// =========================================================================
// Keccak Core Testbench - File-Based Verification
// Reads test vectors from "vectors.txt" generated by Python script.
// Supports: SHA3-256, SHA3-512, SHAKE128, SHAKE256
// Configuration: DWIDTH=256 (32 Bytes), Little Endian Byte Packing
// =========================================================================
`timescale 1ns/1ps

import keccak_pkg::*;

module keccak_core_heavy_tb;

    // =====================================================================
    // 1. TB Configuration & Signals
    // =====================================================================
    localparam CLK_PERIOD = 10;
    localparam string VECTORS_FILE = "verif/vectors.txt";

    // Derived from your Package
    // DWIDTH is 256 bits (32 Bytes)
    localparam int BYTES_PER_BEAT = DWIDTH / 8; 

    logic clk;
    logic rst;

    // DUT Control
    logic                      start_i;
    keccak_mode                keccak_mode_i; // Enum from Pkg
    logic                      stop_i;

    // AXI4-Stream Sink (Input to Core)
    logic [DWIDTH-1:0]         t_data_i;
    logic                      t_valid_i;
    logic                      t_last_i;
    logic [KEEP_WIDTH-1:0]     t_keep_i;
    logic                      t_ready_o;

    // AXI4-Stream Source (Output from Core)
    logic [MAX_OUTPUT_DWIDTH-1:0]   t_data_o;
    logic                           t_valid_o;
    logic                           t_last_o;
    logic [MAX_OUTPUT_DWIDTH/8-1:0] t_keep_o;
    logic                           t_ready_i;

    // Test Vector Structure
    typedef struct {
        string      name;
        keccak_mode mode;            // Enum: SHA3_256, etc.
        string      msg_hex_str;     // Input Message
        string      exp_md_hex_str;  // Expected Hash
        int         output_len_bits; // Length of output to check
    } test_vector_t;

    test_vector_t vectors[$];

    // =====================================================================
    // 2. DUT Instantiation
    // =====================================================================
    keccak_core dut (
        .clk            (clk),
        .rst            (rst),
        .start_i        (start_i),
        .keccak_mode_i  (keccak_mode_i), 
        .stop_i         (stop_i),
        
        // Sink
        .t_data_i       (t_data_i),
        .t_valid_i      (t_valid_i),
        .t_last_i       (t_last_i),
        .t_keep_i       (t_keep_i),
        .t_ready_o      (t_ready_o),
        
        // Source
        .t_data_o       (t_data_o),
        .t_valid_o      (t_valid_o),
        .t_last_o       (t_last_o),
        .t_keep_o       (t_keep_o),
        .t_ready_i      (t_ready_i)
    );

    // =====================================================================
    // 3. Clock & Reset
    // =====================================================================
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end

    task reset_dut();
        rst = 1;
        start_i = 0;
        stop_i = 0;
        t_valid_i = 0;
        t_last_i = 0;
        t_keep_i = 0;
        t_data_i = 0;
        t_ready_i = 0;
        @(posedge clk);
        @(posedge clk);
        rst = 0;
        @(posedge clk);
    endtask

    // =====================================================================
    // 4. Helper Functions
    // =====================================================================
    
    // Hex Char to 4-bit val
    function automatic logic [3:0] hex_char_to_val(byte c);
        if (c >= "0" && c <= "9") return c - "0";
        if (c >= "a" && c <= "f") return c - "a" + 10;
        if (c >= "A" && c <= "F") return c - "A" + 10;
        return 0;
    endfunction

    // String to Enum Mode
    function automatic keccak_mode str_to_mode(string s);
        case (s)
            "SHA3_256": return SHA3_256;
            "SHA3_512": return SHA3_512;
            "SHAKE128": return SHAKE128;
            "SHAKE256": return SHAKE256;
            default: begin
                $error("Unknown mode in text file: %s", s);
                return SHA3_256;
            end
        endcase
    endfunction

    // Convert string "b1ca" -> dynamic array {0xb1, 0xca}
    function automatic void str_to_byte_array(input string s, output logic [7:0] b_arr[]);
        int len = s.len();
        int byte_len = len / 2;
        b_arr = new[byte_len];
        
        for (int i = 0; i < byte_len; i++) begin
            b_arr[i] = {hex_char_to_val(s[i*2]), hex_char_to_val(s[i*2+1])};
        end
    endfunction

    // =====================================================================
    // 5. File Loading Task
    // =====================================================================
    task automatic load_vectors_from_file(input string filename);
        int fd;
        int code;
        string mode_str;
        string msg_str;
        string exp_str;
        int out_len;
        test_vector_t tv;

        $display("Loading vectors from: %s", filename);
        fd = $fopen(filename, "r");
        if (fd == 0) begin
            $fatal(1, "Could not open file: %s. Make sure python script ran and file is in sim dir.", filename);
        end

        // File Format: <MODE> <OUT_BITS> <MSG> <EXPECTED_HASH>
        while (!$feof(fd)) begin
            code = $fscanf(fd, "%s %d %s %s", mode_str, out_len, msg_str, exp_str);
            
            if (code == 4) begin 
                tv.name = $sformatf("%s_%0dbits", mode_str, out_len);
                tv.mode = str_to_mode(mode_str);
                tv.output_len_bits = out_len;
                tv.exp_md_hex_str = exp_str;

                // Handle Empty Message Case (Flagged as "EMPTY" by Python script)
                if (msg_str == "EMPTY") begin
                    tv.msg_hex_str = ""; 
                end else begin
                    tv.msg_hex_str = msg_str;
                end
                
                vectors.push_back(tv);
            end
        end

        $fclose(fd);
        $display("Successfully loaded %0d test vectors.", vectors.size());
    endtask

    // =====================================================================
    // 6. Driver Task: Drive Message
    // =====================================================================
    task automatic drive_msg(input string msg_str);
        logic [7:0] msg_bytes[];
        int total_bytes;
        int sent_bytes = 0;
        int k;

        str_to_byte_array(msg_str, msg_bytes);
        total_bytes = msg_bytes.size();

        // Handle Len=0 Case
        if (total_bytes == 0) begin
            @(posedge clk);
            while (!t_ready_o) @(posedge clk);
            t_valid_i = 1;
            t_last_i  = 1;
            t_keep_i  = '0;
            t_data_i  = '0;
            @(posedge clk);
            t_valid_i = 0;
            t_last_i  = 0;
            return;
        end

        // Drive Data in 256-bit chunks
        while (sent_bytes < total_bytes) begin
            if (!t_valid_i || t_ready_o) begin 
                @(posedge clk);

                t_valid_i = 1;
                t_data_i  = '0;
                t_keep_i  = '0;
                t_last_i  = 0;

                // Pack bytes into little-endian bus (Byte 0 at LSB)
                for (k = 0; k < BYTES_PER_BEAT; k++) begin
                    if ((sent_bytes + k) < total_bytes) begin
                        t_data_i[k*8 +: 8] = msg_bytes[sent_bytes + k];
                        t_keep_i[k]        = 1'b1;
                    end
                end

                sent_bytes += BYTES_PER_BEAT;

                if (sent_bytes >= total_bytes) begin
                    t_last_i = 1'b1;
                end
            end else begin
                @(posedge clk); // Wait while valid is high but ready is low
            end
        end

        // Complete final handshake
        do begin
            @(posedge clk);
        end while (!(t_valid_i && t_ready_o));

        t_valid_i = 0;
        t_last_i  = 0;
        t_keep_i  = 0;
        t_data_i  = 0;
    endtask

    // =====================================================================
    // 7. Monitor Task: Check Response
    // =====================================================================
    task automatic check_response(input string test_name, input string exp_hex, input int out_bits, input keccak_mode mode);
        logic [7:0] collected_bytes[$];
        logic [MAX_OUTPUT_DWIDTH-1:0] current_word;
        logic [MAX_OUTPUT_DWIDTH/8-1:0] current_keep;
        int bytes_needed;
        int i;
        string res_str = "";
        bit is_shake;

        is_shake = (mode == SHAKE128 || mode == SHAKE256);
        bytes_needed = out_bits / 8;
        t_ready_i = 1;

        forever begin
            @(posedge clk);

            if (t_valid_o && t_ready_i) begin
                current_word = t_data_o;
                current_keep = t_keep_o;

                for (i = 0; i < (MAX_OUTPUT_DWIDTH/8); i++) begin
                    if (current_keep[i]) begin
                        collected_bytes.push_back(current_word[i*8 +: 8]);
                    end
                end

                // SHAKE Termination
                if (is_shake && collected_bytes.size() >= bytes_needed) begin
                    stop_i = 1;
                    @(posedge clk);
                    stop_i = 0;
                    break;
                end 

                // SHA3 Termination
                if (!is_shake && t_last_o) begin
                    break;
                end
            end
        end
        t_ready_i = 0;

        // Reconstruct Hex String (Truncate to exact needed bits)
        for (i = 0; i < bytes_needed; i++) begin
            if (i < collected_bytes.size())
                res_str = {res_str, $sformatf("%02x", collected_bytes[i])};
            else
                res_str = {res_str, "XX"};
        end

        // Verify
        if (res_str.tolower() == exp_hex.tolower()) begin
            $display("[PASS] %s", test_name);
        end else begin
            $error("[FAIL] %s", test_name);
            $display("    Expected: %s", exp_hex);
            $display("    Got:      %s", res_str);
        end
    endtask

    // =====================================================================
    // 8. Main Execution
    // =====================================================================
    task automatic run_test(test_vector_t tv);
        $display("----------------------------------------------------------");

        reset_dut();

        fork
            begin
                @(posedge clk);
                start_i = 1;
                keccak_mode_i = tv.mode;
                @(posedge clk);
                start_i = 0;

                drive_msg(tv.msg_hex_str);
            end
            begin
                check_response(tv.name, tv.exp_md_hex_str, tv.output_len_bits, tv.mode);
            end
        join

        #(CLK_PERIOD * 5);
    endtask

    initial begin
        // 1. Load Vectors from file
        load_vectors_from_file(VECTORS_FILE);

        // 2. Run All Tests
        foreach(vectors[i]) begin
            run_test(vectors[i]);
        end

        $display("==========================================================");
        $display("TEST SUITE COMPLETE");
        $display("==========================================================");
        $finish;
    end

endmodule
